/*
  JavaCup Specification for the JavaCup Specification Language
  by Scott Hudson, GVU Center, Georgia Tech, August 1995
  and Frank Flannery, Department of Computer Science, Princeton Univ,
  July 1996
  Bug Fixes: C. Scott Ananian, Dept of Electrical Engineering, Princeton
  University, October 1996. [later Massachusetts Institute of Technology]

  Modified by Martin Geisse to support an extended grammar but without embedded actions.
*/

package name.martingeisse.javapot.input;
import java_cup.runtime.*;
import java.util.Hashtable;
import java.util.Stack;

action code {:
  /** helper routine to clone a new production part adding a given label */
  protected production_part add_lab(production_part part, String lab)
    throws internal_error
    {
      /* if there is no label, or this is an action, just return the original */
      if (lab == null || part.is_action()) return part;

      /* otherwise build a new one with the given label attached */
      return new symbol_part(((symbol_part)part).the_symbol(),lab);
    }

  /** max size of right hand side we will support */
  protected final int MAX_RHS = 200;

  /** array for accumulating right hand side parts */
  protected production_part[] rhs_parts = new production_part[MAX_RHS];

  /** where we are currently in building a right hand side */
  protected int rhs_pos = 0;

  /** start a new right hand side */
  protected void new_rhs() {rhs_pos = 0; }

  /** add a new right hand side part */
  protected void add_rhs_part(production_part part) throws java.lang.Exception
    {
      if (rhs_pos >= MAX_RHS)
	throw new Exception("Internal Error: Productions limited to " +
			     MAX_RHS + " symbols and actions");

      rhs_parts[rhs_pos] = part;
      rhs_pos++;
    }

  /** string to build up multiple part names */
  protected String multipart_name = new String();
  protected Stack multipart_names = new Stack();
  /** append a new name segment to the accumulated multipart name */

//  TUM CHANGES
//   protected void append_multipart(String name)
//     {
//       String dot = "";
//
//       /* if we aren't just starting out, put on a dot */
//       if (multipart_name.length() != 0)  dot = ".";
//
//       multipart_name = multipart_name.concat(dot + name);
//     }
// TUM CHANGES

  /** table of declared symbols -- contains production parts indexed by name */
  protected Hashtable symbols = new Hashtable();

  /** table of just non terminals -- contains non_terminals indexed by name */
  protected Hashtable non_terms = new Hashtable();

  /** declared start non_terminal */
  protected non_terminal start_nt = null;

  /** left hand side non terminal of the current production */
  protected non_terminal lhs_nt;

  /** Current precedence number */
  int _cur_prec = 0;

  /** Current precedence side */
  int _cur_side = assoc.no_prec;

  private int cur_debug_id = 0;
  public int get_new_debug_id() {
   	return cur_debug_id++;
  }

  public String attach_debug_symbol(int id, String code) {
 	if (!parser.debugSymbols)
 		return code;
 	return "//@@CUPDBG" + id + "\n" + code;
  }
:};

parser code {:
 /* override error routines */
  protected Lexer lexer;
  public boolean debugSymbols;
  public void setDebugSymbols(boolean debugSymbols){
  	this.debugSymbols = debugSymbols;
  }
  public void report_fatal_error(
    String   message,
    Object   info)
    {
      done_parsing();
      if (info instanceof Symbol) System.err.println(message+ "\nCan't recover from previous error(s), giving up.",(Symbol)info);
      else System.err.println(message + "\nCan't recover from previous error(s), giving up.",cur_token);
      System.exit(1);
    }

    public void report_error(String message, Object info)
    {
      if (info instanceof Symbol)
         System.err.println(message,(Symbol)info);
      else
         System.err.println(message,cur_token);
    }
:};

init with {:
    ComplexSymbolFactory f = new ComplexSymbolFactory();
    symbolFactory = f;
    lexer = new Lexer(f);
:}

scan with {:
    return lexer.next_token();
:};

terminal QUESTION_MARK, SEMICOLON, COMMA, ASTERISK, DOT, BAR, PLUS,
	COLON, COLON_COLON_EQUALS, PERCENT_PREC,
	PACKAGE, CLASS, TERMINAL, NONTERMINAL, START, PRECEDENCE, LEFT, RIGHT, NONASSOC;
terminal String IDENTIFIER;

nonterminal grammar, symbolDefinitions, symbolDefinition, precedenceList, precedenceDeclaration,
	productionList, production, expression, hierarchicalIdentifier, nonemptyIdentifierList;

precedence left BAR;
precedence nonassoc QUESTION_MARK, ASTERISK, PLUS;

start with grammar;

grammar ::=
	{:
          /* declare "error" as a terminal */
          symbols.put("error", new symbol_part(terminal.error));

          /* declare start non terminal */
          non_terms.put("$START", non_terminal.START_nt);
	:}
	PACKAGE hierarchicalIdentifier:packageName SEMICOLON
	CLASS IDENTIFIER:className SEMICOLON
	symbolDefinitions
	precedenceList
	START IDENTIFIER:startSymbolName SEMICOLON
	productionList
	|
	/* error recovery assuming something went wrong before symbols
	   and we have TERMINAL or NON TERMINAL to sync on.  if we get
	   an error after that, we recover inside symbol_list or
	   production_list
	*/
	error
	symbolDefinitions
	precedenceList
	START IDENTIFIER:startSymbolName SEMICOLON
	productionList
	;


//
// symbol definitions
//

symbolDefinitions ::=
	symbolDefinition
	| symbolDefinitions symbolDefinition
	;

symbolDefinition ::=
	TERMINAL nonemptyIdentifierList SEMICOLON
	| TERMINAL IDENTIFIER:type nonemptyIdentifierList SEMICOLON
	| NONTERMINAL nonemptyIdentifierList SEMICOLON
	| NONTERMINAL IDENTIFIER:type nonemptyIdentifierList SEMICOLON
	| TERMINAL error SEMICOLON
	| NONTERMINAL error SEMICOLON
	;


//
// precedence
//

precedenceList ::=
	// empty
 	| precedenceList precedenceDeclaration
 	;

precedenceDeclaration ::=
	PRECEDENCE LEFT nonemptyIdentifierList SEMICOLON
	| PRECEDENCE RIGHT nonemptyIdentifierList SEMICOLON
	| PRECEDENCE NONASSOC nonemptyIdentifierList SEMICOLON
	;


//
// productions
//

productionList ::=
	production
	| productionList production
	;

production ::=
	IDENTIFIER COLON_COLON_EQUALS expression SEMICOLON
	| error SEMICOLON
	;

expression ::=
	IDENTIFIER
	| IDENTIFIER COLON IDENTIFIER
	| expression IDENTIFIER
	| expression BAR expression
	| expression ASTERISK
	| expression PLUS
	| expression QUESTION_MARK
	;

//
// helpers
//

hierarchicalIdentifier ::=
	IDENTIFIER
	| hierarchicalIdentifier DOT IDENTIFIER
	;

nonemptyIdentifierList ::=
	IDENTIFIER
	| nonemptyIdentifierList COMMA IDENTIFIER
	;
